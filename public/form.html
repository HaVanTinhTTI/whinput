<!DOCTYPE html>
<html >
<head>
  <meta charset="UTF-8" />
  <title>CDCE & K2_Master Data Tools</title>
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/@supabase/supabase-js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      padding: 20px;
    }
    h2 { color: #333; }
    button {
      margin: 5px;
      padding: 8px 16px;
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
    }
    button:hover { background: #0056b3; }
    input[type=file] { margin: 10px 0; }
    #status-sample, #status-update {
      margin-top: 10px;
      font-weight: bold;
      white-space: pre-line;
    }
    .ok { color: green; }
    .error { color: red; }
    .box {
      background: white;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 25px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
	
		
	#loading-spinner {
	  display: none;
	  margin: 20px auto;
	  border: 8px solid #f3f3f3;
	  border-top: 8px solid #007bff;
	  border-radius: 50%;
	  width: 60px;
	  height: 60px;
	  animation: spin 1s linear infinite;
	}

	@keyframes spin {
	  0% { transform: rotate(0deg); }
	  100% { transform: rotate(360deg); }
	}

  </style>
</head>
<body>

  <h2>üì¶ CDCE Sample & K2_Master Tools</h2>

  <!-- ==== DOWNLOAD FILE M·∫™U ==== -->
  <div class="box">
    <h3>‚¨áÔ∏è T·∫£i file m·∫´u CDCE Sample</h3>
    <button id="downloadBtn">T·∫£i file m·∫´u</button>
    <div id="status-sample"></div>
	
  </div>

  <!-- ==== MASS UPDATE K2_MASTER ==== -->
  <div class="box">
    <h3>üì§ Mass Update to K2_Master</h3>
    <input type="file" id="massUpload" multiple accept=".xlsx,.xls,.csv" />
    <button id="massUploadBtn">Upload & Update</button>
	<div id="loading-spinner"></div>
    <div id="status-update"></div>
  </div>
  
    <!-- ==== MASS UPDATE SF_MASTER ==== -->
<div class="box">
  <h3>üì§ Mass Update to SF_Master</h3>
  <input type="file" id="sfMassUpload" accept=".xlsx,.xls,.csv" />
  <button id="sfMassUploadBtn">Upload & Update</button>
  <div id="loading-spinner-sf" style="display:none;">‚è≥ ƒêang c·∫≠p nh·∫≠t...</div>
  <div id="status-update-sf"></div>
</div>


<div class="box">
  <h3>üì§ Mass Update to SCP_Master</h3>
  <input type="file" id="scpMassUpload" accept=".xlsx,.xls,.csv" />
  <button id="scpMassUploadBtn">Upload & Update</button>
  <div id="loading-spinner-scp" style="display:none;">‚è≥ ƒêang c·∫≠p nh·∫≠t...</div>
  <div id="status-update-scp"></div>
</div>




  <script>
		async function downloadCDCESample() {
  try {
    const { data, error } = await client.from('cdce_sample').select('*');
    if (error) return showStatus('‚ùå L·ªói t·∫£i m·∫´u: ' + error.message, true, 'sample');
    if (!data.length) return showStatus('‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu m·∫´u.', true, 'sample');

    const filtered = data.map(({ id, ...rest }) => rest);
    const ws = XLSX.utils.json_to_sheet(filtered);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'cdce_sample');
    XLSX.writeFile(wb, 'cdce_sample.xlsx');
    showStatus('‚úÖ ƒê√£ t·∫£i file m·∫´u!', false, 'sample');
  } catch (err) {
    console.error(err);
    showStatus('‚ùå L·ªói khi t·∫£i file m·∫´u.', true, 'sample');
  }
}
		const client = supabase.createClient(
  'https://chjqassbtcqthueeddou.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNoanFhc3NidGNxdGh1ZWVkZG91Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAxMzY2OTgsImV4cCI6MjA3NTcxMjY5OH0.FbWGSw9sqUkb2_ppErN4QTFGy1Cho-HX4XbR5_-KB0I'
);


const validColumns = [
  'OrgName',
  'eForm Process Status',
  'Item Reference No.',
  'MRDetailID',
  'MRRequestID',
  'ItemCode',
  'ItemSystemDesc',
  'Quantity',
  'Revision'
  
  
];


function showStatus(msg, isError = false, type = 'sample') {
  const div = document.getElementById(type === 'sample' ? 'status-sample' : 'status-update');
  div.innerHTML = msg.replace(/\n/g, '<br>');
  div.className = isError ? 'error' : 'ok';
}

function chunkArray(array, size) {
  const result = [];
  for (let i = 0; i < array.length; i += size) {
    result.push(array.slice(i, i + size));
  }
  return result;
}


async function readExcel(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array', codepage: 65001 });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      const json = XLSX.utils.sheet_to_json(sheet, { defval: null });

      // ‚úÖ B·ªè qua c√°c d√≤ng c√≥ "eForm Process Status" = "Issue Complete"
      const filtered = json.filter(row => 
        row["eForm Process Status"] !== "Issue Complete"
      );

      resolve(filtered);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}


function isRowChanged(newRow, oldRow) {
  for (const key of validColumns) {
    const a = newRow[key];
    const b = oldRow[key];

    // N·∫øu c·∫£ hai ƒë·ªÅu null ho·∫∑c undefined ‚Üí gi·ªëng nhau
    if ((a === null || a === undefined) && (b === null || b === undefined)) continue;

    // N·∫øu c·∫£ hai l√† s·ªë ‚Üí so s√°nh b·∫±ng s·ªë
    if (typeof a === 'number' && typeof b === 'number') {
      if (a !== b) return true;
      continue;
    }

    // N·∫øu l√† chu·ªói ‚Üí chu·∫©n h√≥a: lo·∫°i kho·∫£ng tr·∫Øng, chuy·ªÉn v·ªÅ ch·ªØ th∆∞·ªùng
    if (String(a).trim().toLowerCase() !== String(b).trim().toLowerCase()) {
      return true;
    }
  }
  return false; // kh√¥ng c√≥ thay ƒë·ªïi
}



window.massUpdateK2Master = async function() {
  const startTime = performance.now();
  const input = document.getElementById('massUpload');
  const files = input.files;
  if (!files.length) return showStatus('‚ö†Ô∏è Ch∆∞a ch·ªçn file.', true, 'update');

  let inserted = 0, updated = 0, failed = 0, skipped = 0, total = 0;
  const failedDetails = [];

  // üß© 1Ô∏è‚É£ V√¥ hi·ªáu t·∫•t c·∫£ trigger tr∆∞·ªõc khi upload
  try {
    await client.rpc('exec_sql', {
      sql: `ALTER TABLE public."K2_Master" DISABLE TRIGGER USER;`
    });
    console.log('‚öôÔ∏è ƒê√£ t·∫°m t·∫Øt trigger K2_Master');
  } 
  catch (err) {
    console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ disable trigger:', err.message || err);
  }

  try {
    for (const file of files) {
      const rows = await readExcel(file);
      total += rows.length;
      document.getElementById('loading-spinner').style.display = 'block';

      const mrIDs = rows.map(r => Number(r.MRDetailID)).filter(Boolean);
      const chunkedIDs = chunkArray(mrIDs, 200);
      let existingRows = [];

      for (const chunk of chunkedIDs) {
        const { data, error } = await client
          .from('K2_Master')
          .select('*')
          .in('MRDetailID', chunk);

        if (error) {
          showStatus('‚ùå L·ªói khi load MRDetailID: ' + error.message, true, 'update');
          return;
        }

        existingRows = existingRows.concat(data);
      }

      const existingMap = new Map(existingRows.map(r => [r.MRDetailID, r]));
      const toInsert = [];
      const toUpdate = [];

      for (const row of rows) {
        const mrDetailID = Number(row.MRDetailID);
        if (!mrDetailID) continue;
        const cleanRow = {};
        for (const key of validColumns) {
          if (row.hasOwnProperty(key) && row[key] != null && row[key] !== '') {
            cleanRow[key] = row[key];
          }
        }
        if (!Object.keys(cleanRow).length) continue;

        const oldRow = existingMap.get(mrDetailID);
        if (oldRow) {
          if (isRowChanged(cleanRow, oldRow)) {
            toUpdate.push(cleanRow);
          } else skipped++;
        } else {
          toInsert.push(cleanRow);
        }
      }

      // ‚úÖ Chia nh·ªè batch ƒë·ªÉ tr√°nh timeout
      const batchSize = 100;
      for (let i = 0; i < toUpdate.length; i += batchSize) {
        const batch = toUpdate.slice(i, i + batchSize);
        console.log(`üîÑ Update batch ${i / batchSize + 1} (${batch.length})`);
        const { error } = await client
          .from('K2_Master')
          .upsert(toUpdate, { onConflict: 'OrgName,ItemCode,"Item Reference No.",locator_from,from_sub,lot' });

        if (error) {
          failed += batch.length;
          failedDetails.push(error.message);
        } else updated += batch.length;
        await new Promise(r => setTimeout(r, 300));
      }

      for (let i = 0; i < toInsert.length; i += batchSize) {
        const batch = toInsert.slice(i, i + batchSize);
        console.log(`üü¢ Insert batch ${i / batchSize + 1} (${batch.length})`);
        const { error } = await client.from('K2_Master').insert(batch, { returning: 'minimal' });
        if (error) {
          failed += batch.length;
          failedDetails.push(error.message);
        } else inserted += batch.length;
        await new Promise(r => setTimeout(r, 300));
      }
    }
  } finally {
    // üß© 2Ô∏è‚É£ B·∫≠t l·∫°i trigger sau khi upload xong
    try {
      await client.rpc('exec_sql', {
        sql: `ALTER TABLE public."K2_Master" ENABLE TRIGGER USER;`
      });
      console.log('‚úÖ ƒê√£ b·∫≠t l·∫°i trigger K2_Master');
    } catch (err) {
      console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ b·∫≠t l·∫°i trigger:', err.message || err);
    }
  }

  const endTime = performance.now();
  const elapsedSeconds = ((endTime - startTime) / 1000).toFixed(2);
  const result = `
‚úÖ Ho√†n t·∫•t upload ${files.length} file<br>
‚è±Ô∏è ${elapsedSeconds}s<br>
‚ûï ${inserted} m·ªõi<br>üîÑ ${updated} c·∫≠p nh·∫≠t<br>
‚ùå ${failed} l·ªói<br>
${failed > 0 ? failedDetails.join('<br>') : ''}
  `;
  document.getElementById('loading-spinner').style.display = 'none';
  showStatus(result, failed > 0, 'update');
};





document.getElementById('downloadBtn').addEventListener('click', downloadCDCESample);
document.getElementById('massUploadBtn').addEventListener('click', window.massUpdateK2Master);
document.getElementById('downloadBtn').addEventListener('click', downloadCDCESample);


// ===== ‚ö°Ô∏è MASS UPDATE TO SF_Master (T·ªêI ∆ØU ‚Äì KEY: ItemCode + form_no) =====

// ===== ‚ö°Ô∏è MASS UPDATE TO SF_Master (B·ªé QUA D√íNG TR√ôNG, KH√îNG STOP) =====
// ===== ‚ö°Ô∏è MASS UPDATE TO SF_Master (AUTO CHECK DUPLICATE BEFORE INSERT) =====

function chunk(arr, size = 100) {
  const res = [];
  for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
  return res;
}

async function readExcelSF(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      try {
        const data = new Uint8Array(e.target.result);
        const wb = XLSX.read(data, { type: 'array' });
        const sheetName = wb.SheetNames.includes("Report")
          ? "Report"
          : wb.SheetNames[0];
        const ws = wb.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: null });
        console.log(`üìò ƒê·ªçc sheet: ${sheetName}, t·ªïng ${rows.length} d√≤ng`);
        resolve(rows);
      } catch (err) {
        reject(err);
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

async function massInsertSFFast() {
	  try {
    await client.rpc('exec_sql', {
      sql: `ALTER TABLE public."K2_Master" DISABLE TRIGGER USER;`
    });
    console.log('‚öôÔ∏è ƒê√£ t·∫°m t·∫Øt trigger K2_Master');
  } 
  catch (err) {
    console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ disable trigger:', err.message || err);
  }
  const fileInput = document.getElementById('sfMassUpload');
  const statusDiv = document.getElementById('status-update-sf');
  const spinner = document.getElementById('loading-spinner-sf');
  if (!fileInput.files.length) {
    alert('‚ö†Ô∏è H√£y ch·ªçn file!');
    return;
  }

  spinner.style.display = 'block';
  statusDiv.innerHTML = '';

  try {
    // === ƒê·ªçc file Excel ===
    const file = fileInput.files[0];
    const rows = await readExcelSF(file);

    // === H√†m ƒë·ªçc gi√° tr·ªã theo alias ===
    function valOf(row, aliases) {
      const keys = Object.keys(row);
      for (const alias of aliases) {
        const normAlias = alias.toLowerCase().replace(/[.\s_]+/g, ' ').trim();
        const key = keys.find(k =>
          k.toLowerCase().replace(/[.\s_]+/g, ' ').trim() === normAlias
        );
        if (key != null) return row[key];
      }
      return null;
    }

    // === Chu·∫©n h√≥a d·ªØ li·ªáu ƒë·∫ßu v√†o ===
    const cleaned = rows.map(r => {
      const itemCode = valOf(r, ['Item Code', 'ItemCode']);
      const formNo = valOf(r, ['Form No', 'FormNo', 'Form No.', 'FORM NO']);
      const orgCode = valOf(r, ['Org Code', 'OrgName']);
      const qtyRaw = valOf(r, ['Scrap Qty', 'Quantity', 'SCRAP QTY']);
	  
	  const rev = valOf(r, ['Rev', 'Revision']);
		const subInv = valOf(r, ['Sub Inventory', 'SubInventory', 'SUB INVENTORY']);
		const locator = valOf(r, ['Locator No', 'LocatorNo', 'LOCATOR NO']);


      let qty = null;
      if (qtyRaw != null && qtyRaw !== '') {
        const n = Number(String(qtyRaw).replace(/,/g, '').trim());
        if (!isNaN(n)) qty = n;
      }

      return {
        
        ItemCode: itemCode ? String(itemCode).trim() : '',
        OrgName: orgCode ?? null,
        Quantity: qty,
        "Item Reference No.": formNo ? String(formNo).trim() : '',
		Revision: rev ? String(rev).trim() : 'NA',
		from_sub: subInv ? String(subInv).trim() : 'NA',
		locator_from: locator ? String(locator).trim() : 'NA',


      };
    }).filter(r => r.ItemCode && r["Item Reference No."]);

    if (!cleaned.length) {
      spinner.style.display = 'none';
      statusDiv.textContent = '‚ö†Ô∏è Kh√¥ng c√≥ d√≤ng h·ª£p l·ªá (thi·∫øu ItemCode ho·∫∑c Item Reference No.)';
      statusDiv.className = 'error';
      return;
    }

    // === L·∫•y d·ªØ li·ªáu hi·ªán c√≥ t·ª´ DB ===
    const { data: existing, error: existErr } = await client
      .from('K2_Master')
      .select('OrgName, ItemCode, "Item Reference No."');

    if (existErr) throw existErr;

    // === T·∫°o map key t·ª´ DB ===
    const dbKeys = new Set(
      existing.map(r => `${r.OrgName?.trim()}||${r.ItemCode?.trim()}||${r["Item Reference No."]?.trim()}`)
    );

    // === L·ªçc tr√πng n·ªôi b·ªô + tr√πng v·ªõi DB ===
    const seen = new Set();
    const uniqueRows = [];
    const dupRows = [];

    for (const r of cleaned) {
      const key = [
  r.OrgName?.trim(),
  r.ItemCode?.trim(),
  r["Item Reference No."]?.trim(),
  r.Revision?.trim(),
  r.Quantity?.toString().trim(),
  r.from_sub?.trim(),
  r.locator_from?.trim()
].join('||');

      if (dbKeys.has(key) || seen.has(key)) {
        dupRows.push(r);
      } else {
        seen.add(key);
        uniqueRows.push(r);
      }
    }

    // === Chia batch & insert ===
    const chunk = (arr, size = 100) => {
      const res = [];
      for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
      return res;
    };

    let inserted = 0, failed = 0;
    const batches = chunk(uniqueRows, 100);

    for (const [index, b] of batches.entries()) {
      console.log(`üü© Batch ${index + 1}/${batches.length}: ${b.length} rows`);
      const { error } = await client.from('K2_Master').insert(b, { returning: 'minimal' });

      if (error) {
        console.error(`‚ùå Batch ${index + 1} l·ªói:`, error.message);
        failed += b.length;
      } else {
        inserted += b.length;
      }

      await new Promise(r => setTimeout(r, 120));
	  
    }
try {
      await client.rpc('exec_sql', {
        sql: `ALTER TABLE public."K2_Master" ENABLE TRIGGER USER;`
      });
      console.log('‚úÖ ƒê√£ b·∫≠t l·∫°i trigger K2_Master');
    } catch (err) {
      console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ b·∫≠t l·∫°i trigger:', err.message || err);
    }
  
  // === K·∫øt qu·∫£ ===
spinner.style.display = 'none';

// üß© Hi·ªÉn th·ªã chi ti·∫øt c√°c d√≤ng tr√πng n·ªôi b·ªô
let resultHTML = '';
if (dupRows.length > 0) {
  // T·∫°o b·∫£ng HTML chi ti·∫øt
  let rowsHTML = '';
  dupRows.forEach((r, i) => {
    rowsHTML += `
      <tr>
        <td>${i + 1}</td>
        <td>${r.OrgName || ''}</td>
        <td>${r.ItemCode || ''}</td>
        <td>${r["Item Reference No."] || ''}</td>
        <td>${r.Revision || ''}</td>
        <td>${r.Quantity || ''}</td>
        <td>${r.from_sub || ''}</td>
        <td>${r.locator_from || ''}</td>
      </tr>`;
  });

  const tableHTML = `
    <h4>‚ö†Ô∏è Danh s√°ch ${dupRows.length} d√≤ng b·ªã tr√πng n·ªôi b·ªô / ƒë√£ t·ªìn t·∫°i</h4>
    <table border="1" cellspacing="0" cellpadding="4"
      style="border-collapse:collapse; width:100%; font-size:13px;">
      <thead style="background:#f0f0f0; text-align:left;">
        <tr>
          <th>#</th>
          <th>OrgName</th>
          <th>ItemCode</th>
          <th>Item Reference No.</th>
          <th>Revision</th>
          <th>Quantity</th>
          <th>from_sub</th>
          <th>locator_from</th>
        </tr>
      </thead>
      <tbody>${rowsHTML}</tbody>
    </table>
    <button id="exportDupBtn" style="
      margin-top:10px; background:#22c55e; color:white;
      border:none; padding:8px 12px; border-radius:6px; cursor:pointer;">
      ‚¨áÔ∏è Export duplicate rows
    </button>
  `;

  resultHTML =
    '‚úÖ ƒê√£ th√™m m·ªõi: ' + inserted + ' d√≤ng<br>' +
    '‚ö†Ô∏è B·ªè qua (ƒë√£ t·ªìn t·∫°i ho·∫∑c tr√πng n·ªôi b·ªô): ' + dupRows.length + ' d√≤ng<br>' +
    '‚ùå L·ªói kh√°c: ' + failed + ' d√≤ng<br><br>' +
    tableHTML;
} else {
  resultHTML =
    '‚úÖ ƒê√£ th√™m m·ªõi: ' + inserted + ' d√≤ng<br>' +
    '‚ö†Ô∏è Kh√¥ng c√≥ d√≤ng tr√πng n·ªôi b·ªô<br>' +
    '‚ùå L·ªói kh√°c: ' + failed + ' d√≤ng';
}

statusDiv.innerHTML = resultHTML;
statusDiv.className = failed ? 'error' : 'ok';

// üß© Export ra Excel
const exportBtn = document.getElementById('exportDupBtn');
if (exportBtn) {
  exportBtn.addEventListener('click', () => {
  // üß© Sort theo ItemCode A ‚Üí Z
  const sortedDup = dupRows.slice().sort((a, b) => {
    const itemA = String(a.ItemCode || '').toLowerCase();
    const itemB = String(b.ItemCode || '').toLowerCase();
    return itemA.localeCompare(itemB, 'en', { numeric: true });
  });

  const ws = XLSX.utils.json_to_sheet(sortedDup);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Duplicate_Rows');
    XLSX.writeFile(wb, 'SF_Duplicate_Internal.xlsx');
    alert(`‚úÖ ƒê√£ export ${dupRows.length} d√≤ng tr√πng n·ªôi b·ªô ra file SF_Duplicate_Internal.xlsx`);
  });
}

  } catch (err) {
    console.error('‚ùå L·ªói t·ªïng th·ªÉ:', err);
    statusDiv.textContent = '‚ùå L·ªói: ' + err.message;
    statusDiv.className = 'error';
  } finally {
    spinner.style.display = 'none';
    // Lu√¥n b·∫≠t l·∫°i trigger n·∫øu c√≥ l·ªói b·∫•t ng·ªù
    try {
      await client.rpc('exec_sql', {
        sql: `ALTER TABLE public."K2_Master" ENABLE TRIGGER USER;`
      });
    } catch (err) {
      console.warn('‚ö†Ô∏è Kh√¥ng th·ªÉ b·∫≠t l·∫°i trigger trong finally:', err.message || err);
    }
  }
}
  
// üß© G·∫ÆN S·ª∞ KI·ªÜN CHO N√öT UPLOAD
document.addEventListener('DOMContentLoaded', () => {
  const btn = document.getElementById('sfMassUploadBtn');
  if (btn) {
    btn.addEventListener('click', () => {
      console.log("üöÄ G·ªçi massInsertSFFast()...");
      massInsertSFFast();
    });
  } else {
    console.warn("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y n√∫t #sfMassUploadBtn trong DOM");
  }
});

/////SCP
// ===== ‚ö°Ô∏è MASS UPDATE TO SCP_Master (KEY = ItemCode + Item Reference No.) =====

async function readExcelSCP(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      try {
        const data = new Uint8Array(e.target.result);
        const wb = XLSX.read(data, { type: 'array' });

        // ∆∞u ti√™n sheet "Report" n·∫øu c√≥
        const sheetName = wb.SheetNames.includes("Report") ? "Report" : wb.SheetNames[0];
        const ws = wb.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: null });
        console.log(`üìò ƒê·ªçc sheet: ${sheetName}, t·ªïng ${rows.length} d√≤ng`);
        resolve(rows);
      } catch (err) {
        console.error("‚ùå L·ªói ƒë·ªçc Excel:", err);
        reject(err);
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

async function massInsertSCP() {
  const fileInput = document.getElementById('scpMassUpload');
  const statusDiv = document.getElementById('status-update-scp');
  const spinner = document.getElementById('loading-spinner-scp');
  if (!fileInput.files.length) return alert('‚ö†Ô∏è H√£y ch·ªçn file SCP!');

  spinner.style.display = 'block';
  statusDiv.innerHTML = '';

  try {
    const file = fileInput.files[0];
    const rows = await readExcelSCP(file);

    // ===== Chu·∫©n h√≥a header =====
    function valOf(row, aliases) {
      const keys = Object.keys(row);
      for (const alias of aliases) {
        const normAlias = String(alias).toLowerCase().replace(/[.\s_]+/g, ' ').trim();
        const key = keys.find(k =>
          String(k).toLowerCase().replace(/[.\s_]+/g, ' ').trim() === normAlias
        );
        if (key != null) return row[key];
      }
      return null;
    }

    // ===== Chu·∫©n h√≥a d·ªØ li·ªáu =====
    const cleaned = rows.map(r => {
      const cbNo = valOf(r, ['CB no', 'CB', 'cb no']);
      const scp = valOf(r, ['SCP/ WRO', 'SCP WRO', 'SCP']);
      const partNo = valOf(r, ['Part No.', 'Part No', 'PART NO']);
      const qtyRaw = valOf(r, ['Quantity', 'Qty']);
      const org = valOf(r, ['Org', 'OrgName']);

      const refNo = [scp, cbNo].filter(Boolean).join('&'); // SCP/WRO + CB no

      let qty = null;
      if (qtyRaw != null && qtyRaw !== '') {
        const n = Number(String(qtyRaw).replace(/,/g, '').trim());
        if (!isNaN(n)) qty = n;
      }

      return {
        "Item Reference No.": refNo ? String(refNo).trim() : '',
        "ItemCode": partNo ? String(partNo).trim() : '',
        "Quantity": qty,
        "OrgName": org ? String(org).trim() : ''
      };
    }).filter(r => r["ItemCode"] && r["Item Reference No."]);

    if (!cleaned.length) {
      spinner.style.display = 'none';
      statusDiv.innerHTML = '‚ö†Ô∏è Kh√¥ng c√≥ d√≤ng h·ª£p l·ªá (thi·∫øu ItemCode ho·∫∑c Item Reference No.)';
      statusDiv.className = 'error';
      return;
    }

    // ===== L·∫•y d·ªØ li·ªáu hi·ªán c√≥ trong K2_Master =====
    const { data: existing, error: existErr } = await client
      .from('K2_Master')
      .select('ItemCode, "Item Reference No."');

    if (existErr) throw existErr;

    const existMap = new Map();
    existing.forEach(r => {
      const key = `${r.ItemCode}||${r["Item Reference No."]}`;
      existMap.set(key, true);
    });

    // ===== Ch·ªâ insert n·∫øu ch∆∞a t·ªìn t·∫°i =====
    const newRows = [];
    let dupCount = 0;
    for (const r of cleaned) {
      const key = `${r.ItemCode}||${r["Item Reference No."]}`;
      if (existMap.has(key)) {
        dupCount++;
      } else {
        newRows.push(r);
      }
    }

    // ===== Ch√®n batch =====
    const chunk = (arr, size = 200) => {
      const res = [];
      for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
      return res;
    };

    let inserted = 0, failed = 0;
    const batches = chunk(newRows, 200);

    for (const [index, b] of batches.entries()) {
      console.log(`üü© Batch ${index + 1}/${batches.length}: ${b.length} d√≤ng`);
      const { error } = await client.from('K2_Master').insert(b, { returning: 'minimal' });
      if (error) {
        console.error(`‚ùå Batch ${index + 1} l·ªói:`, error.message);
        failed += b.length;
      } else {
        inserted += b.length;
      }
      await new Promise(r => setTimeout(r, 150));
    }

    // ===== K·∫øt qu·∫£ =====
    spinner.style.display = 'none';
    statusDiv.innerHTML = `
‚úÖ ƒê√£ th√™m m·ªõi: ${inserted} d√≤ng<br>
‚ö†Ô∏è ƒê√£ t·ªìn t·∫°i (b·ªè qua): ${dupCount} d√≤ng<br>
‚ùå L·ªói: ${failed} d√≤ng
    `;
    statusDiv.className = failed ? 'error' : 'ok';

  } catch (err) {
    spinner.style.display = 'none';
    statusDiv.innerHTML = `‚ùå L·ªói: ${err.message}`;
    statusDiv.className = 'error';
  }
}

document.getElementById('scpMassUploadBtn')
  .addEventListener('click', massInsertSCP);


</script>
  
</body>
</html> 
