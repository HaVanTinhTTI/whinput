<!DOCTYPE html>
<html >
<head>
  <meta charset="UTF-8" />
  <title>CDCE & K2_Master Data Tools</title>
  <script src="https://unpkg.com/xlsx/dist/xlsx.full.min.js"></script>
  <script src="https://unpkg.com/@supabase/supabase-js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f7f7;
      padding: 20px;
    }
    h2 { color: #333; }
    button {
      margin: 5px;
      padding: 8px 16px;
      cursor: pointer;
      background: #007bff;
      color: white;
      border: none;
      border-radius: 5px;
    }
    button:hover { background: #0056b3; }
    input[type=file] { margin: 10px 0; }
    #status-sample, #status-update {
      margin-top: 10px;
      font-weight: bold;
      white-space: pre-line;
    }
    .ok { color: green; }
    .error { color: red; }
    .box {
      background: white;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 25px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    }
	
		
	#loading-spinner {
	  display: none;
	  margin: 20px auto;
	  border: 8px solid #f3f3f3;
	  border-top: 8px solid #007bff;
	  border-radius: 50%;
	  width: 60px;
	  height: 60px;
	  animation: spin 1s linear infinite;
	}

	@keyframes spin {
	  0% { transform: rotate(0deg); }
	  100% { transform: rotate(360deg); }
	}

  </style>
</head>
<body>

  <h2>üì¶ CDCE Sample & K2_Master Tools</h2>

  <!-- ==== DOWNLOAD FILE M·∫™U ==== -->
  <div class="box">
    <h3>‚¨áÔ∏è T·∫£i file m·∫´u CDCE Sample</h3>
    <button id="downloadBtn">T·∫£i file m·∫´u</button>
    <div id="status-sample"></div>
	
  </div>

  <!-- ==== MASS UPDATE K2_MASTER ==== -->
  <div class="box">
    <h3>üì§ Mass Update to K2_Master</h3>
    <input type="file" id="massUpload" multiple accept=".xlsx,.xls,.csv" />
    <button id="massUploadBtn">Upload & Update</button>
	<div id="loading-spinner"></div>
    <div id="status-update"></div>
  </div>
  
    <!-- ==== MASS UPDATE SF_MASTER ==== -->
<div class="box">
  <h3>üì§ Mass Update to SF_Master</h3>
  <input type="file" id="sfMassUpload" accept=".xlsx,.xls,.csv" />
  <button id="sfMassUploadBtn">Upload & Update</button>
  <div id="loading-spinner-sf" style="display:none;">‚è≥ ƒêang c·∫≠p nh·∫≠t...</div>
  <div id="status-update-sf"></div>
</div>


<div class="box">
  <h3>üì§ Mass Update to SCP_Master</h3>
  <input type="file" id="scpMassUpload" accept=".xlsx,.xls,.csv" />
  <button id="scpMassUploadBtn">Upload & Update</button>
  <div id="loading-spinner-scp" style="display:none;">‚è≥ ƒêang c·∫≠p nh·∫≠t...</div>
  <div id="status-update-scp"></div>
</div>




  <script>
		async function downloadCDCESample() {
  try {
    const { data, error } = await client.from('cdce_sample').select('*');
    if (error) return showStatus('‚ùå L·ªói t·∫£i m·∫´u: ' + error.message, true, 'sample');
    if (!data.length) return showStatus('‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu m·∫´u.', true, 'sample');

    const filtered = data.map(({ id, ...rest }) => rest);
    const ws = XLSX.utils.json_to_sheet(filtered);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'cdce_sample');
    XLSX.writeFile(wb, 'cdce_sample.xlsx');
    showStatus('‚úÖ ƒê√£ t·∫£i file m·∫´u!', false, 'sample');
  } catch (err) {
    console.error(err);
    showStatus('‚ùå L·ªói khi t·∫£i file m·∫´u.', true, 'sample');
  }
}
		const client = supabase.createClient(
  'https://chjqassbtcqthueeddou.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNoanFhc3NidGNxdGh1ZWVkZG91Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjAxMzY2OTgsImV4cCI6MjA3NTcxMjY5OH0.FbWGSw9sqUkb2_ppErN4QTFGy1Cho-HX4XbR5_-KB0I'
);

const validColumns = [
  'OrgName','eForm Process Status','Item Reference No.','MRDetailID', 'MRRequestID', 'ItemCode', 'ItemSystemDesc', 'Quantity',
  'QuantityIssued', 'QuantityDefect', 'QuantityPerAssembly',
  'Revision', 'StatusDesc', 'SubmittedDate', 'CompletedDate',
  'ERPReasonName', 'ERPReason', 'ResponsibleDeptCode', 'ResponsibleDeptDesc'
];

function showStatus(msg, isError = false, type = 'sample') {
  const div = document.getElementById(type === 'sample' ? 'status-sample' : 'status-update');
  div.innerHTML = msg.replace(/\n/g, '<br>');
  div.className = isError ? 'error' : 'ok';
}

function chunkArray(array, size) {
  const result = [];
  for (let i = 0; i < array.length; i += size) {
    result.push(array.slice(i, i + size));
  }
  return result;
}


async function readExcel(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: 'array', codepage: 65001 });
      const sheet = workbook.Sheets[workbook.SheetNames[0]];
      const json = XLSX.utils.sheet_to_json(sheet, { defval: null });

      // ‚úÖ B·ªè qua c√°c d√≤ng c√≥ "eForm Process Status" = "Issue Complete"
      const filtered = json.filter(row => 
        row["eForm Process Status"] !== "Issue Complete"
      );

      resolve(filtered);
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}


function isRowChanged(newRow, oldRow) {
  for (const key of validColumns) {
    const a = newRow[key];
    const b = oldRow[key];

    // N·∫øu c·∫£ hai ƒë·ªÅu null ho·∫∑c undefined ‚Üí gi·ªëng nhau
    if ((a === null || a === undefined) && (b === null || b === undefined)) continue;

    // N·∫øu c·∫£ hai l√† s·ªë ‚Üí so s√°nh b·∫±ng s·ªë
    if (typeof a === 'number' && typeof b === 'number') {
      if (a !== b) return true;
      continue;
    }

    // N·∫øu l√† chu·ªói ‚Üí chu·∫©n h√≥a: lo·∫°i kho·∫£ng tr·∫Øng, chuy·ªÉn v·ªÅ ch·ªØ th∆∞·ªùng
    if (String(a).trim().toLowerCase() !== String(b).trim().toLowerCase()) {
      return true;
    }
  }
  return false; // kh√¥ng c√≥ thay ƒë·ªïi
}


window.massUpdateK2Master = async function()
 {
		const startTime = performance.now();
	  const input = document.getElementById('massUpload');
	  const files = input.files;
	  if (!files.length) return showStatus('‚ö†Ô∏è Ch∆∞a ch·ªçn file.', true, 'update');

	  let inserted = 0, updated = 0, failed = 0, skipped = 0, total = 0;
	  const failedDetails = [];

	  for (const file of files) {
		const rows = await readExcel(file);
		total += rows.length;
	//lock
	document.getElementById('loading-spinner').style.display = 'block'

		const mrIDs = rows.map(r => Number(r.MRDetailID)).filter(Boolean);
		const chunkedIDs = chunkArray(mrIDs, 200);
		let existingRows = [];

		for (const chunk of chunkedIDs) {
		  const { data, error } = await client
			.from('K2_Master')
			.select('*')
			.in('MRDetailID', chunk);

		  if (error) {
			showStatus('‚ùå L·ªói khi load MRDetailID: ' + error.message, true, 'update');
			return;
		  }

		  existingRows = existingRows.concat(data);
		}

		const existingMap = new Map(existingRows.map(r => [r.MRDetailID, r]));
		const toInsert = [];
		const toUpdate = [];

		for (const row of rows) {
		  const mrDetailID = Number(row.MRDetailID);
		  if (!mrDetailID) continue;

		  const cleanRow = {};
		  for (const key of validColumns) {
			if (row.hasOwnProperty(key) && row[key] !== null && row[key] !== undefined && row[key] !== '') {
			  cleanRow[key] = row[key];
			}
		  }

		  if (Object.keys(cleanRow).length === 0) continue;

		  const oldRow = existingMap.get(mrDetailID);
		  if (oldRow) {
			if (isRowChanged(cleanRow, oldRow)) {
			  toUpdate.push(cleanRow);
			} else {
			  skipped++;
			}
		  } else {
			toInsert.push(cleanRow);
		  }
		}

		if (toUpdate.length) {
		  const { error: upErr } = await client.from('K2_Master').upsert(toUpdate, { onConflict: 'MRDetailID' });
		  if (upErr) {
			failed += toUpdate.length;
			failedDetails.push('‚ùå Update batch l·ªói: ' + upErr.message);
		  } else {
			updated += toUpdate.length;
		  }
		}

		

		if (toInsert.length) {
		 
		  const { error: inErr } = await client.from('K2_Master')
		 
		  
		  .insert(toInsert);
		  if (inErr) {
			failed += toInsert.length;
			failedDetails.push('‚ùå Insert batch l·ªói: ' + inErr.message);
		  } else {
			inserted += toInsert.length;
		  }
		}
  }

const endTime = performance.now();
const elapsedSeconds = ((endTime - startTime) / 1000).toFixed(2);

  const result = `
‚úÖ Ho√†n t·∫•t upload ${files.length} file<br>
‚è±Ô∏è Th·ªùi gian x·ª≠ l√Ω: ${elapsedSeconds} gi√¢y<br>
T·ªïng ${total} d√≤ng:<br>
‚ûï ${inserted} m·ªõi<br>
üîÑ ${updated} c·∫≠p nh·∫≠t<br>
‚è≠Ô∏è ${skipped} b·ªè qua<br>
‚ùå ${failed} l·ªói<br>
${failed > 0 ? '<br><b>Chi ti·∫øt l·ªói:</b><br>' + failedDetails.join('<br>') : ''}
  `;
  document.getElementById('loading-spinner').style.display = 'none';
  showStatus(result, failed > 0, 'update');
};



document.getElementById('downloadBtn').addEventListener('click', downloadCDCESample);
document.getElementById('massUploadBtn').addEventListener('click', window.massUpdateK2Master);
document.getElementById('downloadBtn').addEventListener('click', downloadCDCESample);


// ===== ‚ö°Ô∏è MASS UPDATE TO SF_Master (T·ªêI ∆ØU ‚Äì KEY: ItemCode + form_no) =====


function chunk(arr, size = 200) {
  const res = [];
  for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
  return res;
}

async function readExcelSF(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      try {
        const data = new Uint8Array(e.target.result);
        const wb = XLSX.read(data, { type: 'array' });

        // ‚úÖ C√≥ th·ªÉ t·ª± ƒë·ªông ch·ªçn sheet ƒë·∫ßu ti√™n ho·∫∑c sheet "Report"
        const sheetName = wb.SheetNames.includes("Report")
          ? "Report"
          : wb.SheetNames[0];

        const ws = wb.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: null });
        console.log(`üìò ƒê·ªçc sheet: ${sheetName}, t·ªïng ${rows.length} d√≤ng`);
        resolve(rows);
      } catch (err) {
        console.error("‚ùå L·ªói ƒë·ªçc Excel:", err);
        reject(err);
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

async function massInsertSFFast() {
  const fileInput = document.getElementById('sfMassUpload');
  const statusDiv = document.getElementById('status-update-sf');
  const spinner = document.getElementById('loading-spinner-sf');
  if (!fileInput.files.length) {
    alert('‚ö†Ô∏è H√£y ch·ªçn file!');
    return;
  }

  spinner.style.display = 'block';
  statusDiv.innerHTML = '';

  try {
    const file = fileInput.files[0];
    const rows = await readExcelSF(file);

    // H√†m l·∫•y gi√° tr·ªã theo nhi·ªÅu bi·∫øn th·ªÉ header
    function valOf(row, aliases) {
      const keys = Object.keys(row);
      for (const alias of aliases) {
        const normAlias = String(alias).toLowerCase().replace(/[.\s_]+/g, ' ').trim();
        const key = keys.find(k =>
          String(k).toLowerCase().replace(/[.\s_]+/g, ' ').trim() === normAlias
        );
        if (key != null) return row[key];
      }
      return null;
    }

    // Chu·∫©n h√≥a d·ªØ li·ªáu
    const cleaned = rows.map(r => {
  const itemCode = valOf(r, ['Item Code', 'ItemCode', 'ITEM CODE', 'item code']);
  const formNo   = valOf(r, ['Form No', 'Form No.', 'FORM NO', 'form no']); // <== ƒë·ªçc t·ª´ Excel
  const orgCode  = valOf(r, ['Org Code', 'OrgCode', 'ORG CODE']);
  const reason   = valOf(r, ['Reason', 'ERPReason']);
  const qtyRaw   = valOf(r, ['Scrap Qty', 'Quantity', 'SCRAP QTY']);

        // √©p ki·ªÉu s·ªë an to√†n
  let qty = null;
  if (qtyRaw != null && qtyRaw !== '') {
    const n = Number(String(qtyRaw).replace(/,/g, '').trim());
    if (!isNaN(n)) qty = n;
  }

  return {
    ERPReason: reason ?? null,
    ItemCode: itemCode ? String(itemCode).trim() : '',
    OrgName: orgCode ?? null,
    Quantity: qty,
    "Item Reference No.": formNo ? String(formNo).trim() : '' // <== n·∫°p v√†o c·ªôt K2_Master
  };
}).filter(r => r.ItemCode && r["Item Reference No."]);

    if (!cleaned.length) {
      spinner.style.display = 'none';
      statusDiv.innerHTML = '‚ö†Ô∏è Kh√¥ng c√≥ d√≤ng h·ª£p l·ªá (thi·∫øu ItemCode ho·∫∑c Item Reference No.)';
      statusDiv.className = 'error';
      return;
    }

    // L·∫•y d·ªØ li·ªáu hi·ªán c√≥
    const { data: existing, error: existErr } = await client
      .from('K2_Master')
      .select('ItemCode, "Item Reference No."');

    if (existErr) throw existErr;

    const existMap = new Map();
    existing.forEach(r => existMap.set(`${r.ItemCode}||${r["Item Reference No."]}`, true));

    // Ph√¢n lo·∫°i d√≤ng m·ªõi / tr√πng
    const newRows = [];
    let dupCount = 0;
    for (const r of cleaned) {
      const key = `${r.ItemCode}||${r["Item Reference No."]}`;
      if (existMap.has(key)) {
        dupCount++;
      } else {
        const safeRow = {};
        for (const [k, v] of Object.entries(r)) {
          if (v === undefined) continue;
          if (k === 'Quantity' && (v === null || isNaN(v))) continue;
          safeRow[k] = v;
        }
        if (Object.keys(safeRow).length > 0) newRows.push(safeRow);
      }
    }

    // Insert batch
    let inserted = 0, failed = 0;
    const batches = chunk(newRows, 200);

    for (const [index, b] of batches.entries()) {
      console.log(`üü© Batch ${index + 1}/${batches.length}: ${b.length} rows`);
      const { error } = await client.from('K2_Master').insert(b, { returning: 'minimal' });
      if (error) {
        console.error(`‚ùå Batch ${index + 1} l·ªói:`, error.message);
        failed += b.length;
      } else {
        inserted += b.length;
      }
      await new Promise(r => setTimeout(r, 150));
    }

    // K·∫øt qu·∫£
    spinner.style.display = 'none';
    statusDiv.innerHTML = `
‚úÖ ƒê√£ ch√®n m·ªõi: ${inserted} d√≤ng<br>
‚ö†Ô∏è ƒê√£ t·ªìn t·∫°i (b·ªè qua): ${dupCount} d√≤ng<br>
‚ùå L·ªói: ${failed} d√≤ng
    `;
    statusDiv.className = failed ? 'error' : 'ok';

  } catch (err) {
    spinner.style.display = 'none';
    statusDiv.innerHTML = `‚ùå L·ªói: ${err.message}`;
    statusDiv.className = 'error';
  }
}


document.getElementById('sfMassUploadBtn')
  .addEventListener('click', massInsertSFFast);

/////SCP
// ===== ‚ö°Ô∏è MASS UPDATE TO SCP_Master (KEY = ItemCode + Item Reference No.) =====

async function readExcelSCP(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = e => {
      try {
        const data = new Uint8Array(e.target.result);
        const wb = XLSX.read(data, { type: 'array' });

        // ∆∞u ti√™n sheet "Report" n·∫øu c√≥
        const sheetName = wb.SheetNames.includes("Report") ? "Report" : wb.SheetNames[0];
        const ws = wb.Sheets[sheetName];
        const rows = XLSX.utils.sheet_to_json(ws, { defval: null });
        console.log(`üìò ƒê·ªçc sheet: ${sheetName}, t·ªïng ${rows.length} d√≤ng`);
        resolve(rows);
      } catch (err) {
        console.error("‚ùå L·ªói ƒë·ªçc Excel:", err);
        reject(err);
      }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

async function massInsertSCP() {
  const fileInput = document.getElementById('scpMassUpload');
  const statusDiv = document.getElementById('status-update-scp');
  const spinner = document.getElementById('loading-spinner-scp');
  if (!fileInput.files.length) return alert('‚ö†Ô∏è H√£y ch·ªçn file SCP!');

  spinner.style.display = 'block';
  statusDiv.innerHTML = '';

  try {
    const file = fileInput.files[0];
    const rows = await readExcelSCP(file);

    // ===== Chu·∫©n h√≥a header =====
    function valOf(row, aliases) {
      const keys = Object.keys(row);
      for (const alias of aliases) {
        const normAlias = String(alias).toLowerCase().replace(/[.\s_]+/g, ' ').trim();
        const key = keys.find(k =>
          String(k).toLowerCase().replace(/[.\s_]+/g, ' ').trim() === normAlias
        );
        if (key != null) return row[key];
      }
      return null;
    }

    // ===== Chu·∫©n h√≥a d·ªØ li·ªáu =====
    const cleaned = rows.map(r => {
      const cbNo = valOf(r, ['CB no', 'CB', 'cb no']);
      const scp = valOf(r, ['SCP/ WRO', 'SCP WRO', 'SCP']);
      const partNo = valOf(r, ['Part No.', 'Part No', 'PART NO']);
      const qtyRaw = valOf(r, ['Quantity', 'Qty']);
      const org = valOf(r, ['Org', 'OrgName']);

      const refNo = [scp, cbNo].filter(Boolean).join('&'); // SCP/WRO + CB no

      let qty = null;
      if (qtyRaw != null && qtyRaw !== '') {
        const n = Number(String(qtyRaw).replace(/,/g, '').trim());
        if (!isNaN(n)) qty = n;
      }

      return {
        "Item Reference No.": refNo ? String(refNo).trim() : '',
        "ItemCode": partNo ? String(partNo).trim() : '',
        "Quantity": qty,
        "OrgName": org ? String(org).trim() : ''
      };
    }).filter(r => r["ItemCode"] && r["Item Reference No."]);

    if (!cleaned.length) {
      spinner.style.display = 'none';
      statusDiv.innerHTML = '‚ö†Ô∏è Kh√¥ng c√≥ d√≤ng h·ª£p l·ªá (thi·∫øu ItemCode ho·∫∑c Item Reference No.)';
      statusDiv.className = 'error';
      return;
    }

    // ===== L·∫•y d·ªØ li·ªáu hi·ªán c√≥ trong K2_Master =====
    const { data: existing, error: existErr } = await client
      .from('K2_Master')
      .select('ItemCode, "Item Reference No."');

    if (existErr) throw existErr;

    const existMap = new Map();
    existing.forEach(r => {
      const key = `${r.ItemCode}||${r["Item Reference No."]}`;
      existMap.set(key, true);
    });

    // ===== Ch·ªâ insert n·∫øu ch∆∞a t·ªìn t·∫°i =====
    const newRows = [];
    let dupCount = 0;
    for (const r of cleaned) {
      const key = `${r.ItemCode}||${r["Item Reference No."]}`;
      if (existMap.has(key)) {
        dupCount++;
      } else {
        newRows.push(r);
      }
    }

    // ===== Ch√®n batch =====
    const chunk = (arr, size = 200) => {
      const res = [];
      for (let i = 0; i < arr.length; i += size) res.push(arr.slice(i, i + size));
      return res;
    };

    let inserted = 0, failed = 0;
    const batches = chunk(newRows, 200);

    for (const [index, b] of batches.entries()) {
      console.log(`üü© Batch ${index + 1}/${batches.length}: ${b.length} d√≤ng`);
      const { error } = await client.from('K2_Master').insert(b, { returning: 'minimal' });
      if (error) {
        console.error(`‚ùå Batch ${index + 1} l·ªói:`, error.message);
        failed += b.length;
      } else {
        inserted += b.length;
      }
      await new Promise(r => setTimeout(r, 150));
    }

    // ===== K·∫øt qu·∫£ =====
    spinner.style.display = 'none';
    statusDiv.innerHTML = `
‚úÖ ƒê√£ th√™m m·ªõi: ${inserted} d√≤ng<br>
‚ö†Ô∏è ƒê√£ t·ªìn t·∫°i (b·ªè qua): ${dupCount} d√≤ng<br>
‚ùå L·ªói: ${failed} d√≤ng
    `;
    statusDiv.className = failed ? 'error' : 'ok';

  } catch (err) {
    spinner.style.display = 'none';
    statusDiv.innerHTML = `‚ùå L·ªói: ${err.message}`;
    statusDiv.className = 'error';
  }
}

document.getElementById('scpMassUploadBtn')
  .addEventListener('click', massInsertSCP);


</script>
  
</body>
</html> 
